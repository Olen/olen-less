#!/usr/bin/env bash
#
# olen-less - A smarter less that uses specialized tools for different file types
#

set -euo pipefail

# Check if a command exists
has_cmd() {
    command -v "$1" &>/dev/null
}

# Detect content type from file content (first few bytes)
detect_content_type() {
    local content="$1"
    local first_line
    first_line=$(echo "$content" | head -n1)

    # JSON detection
    # Objects starting with { are likely JSON
    if [[ "$first_line" =~ ^[[:space:]]*\{ ]]; then
        echo "json"
        return
    fi
    # Arrays starting with [ need more care to distinguish from INI sections
    # INI sections look like [section_name] - text followed by ]
    # JSON arrays have: [], [{, [", [digit, [true, [false, [null
    if [[ "$first_line" =~ ^[[:space:]]*\[ ]]; then
        # Strip the opening bracket and any following whitespace
        local after_bracket="${first_line#*[}"
        local ws_prefix="${after_bracket%%[![:space:]]*}"
        after_bracket="${after_bracket#"$ws_prefix"}"
        # Check if it looks like JSON array content (not an INI section header)
        # Note: ] must be first in character class, - must be last
        if [[ "$after_bracket" =~ ^[]{}\"0-9-] ]] || \
           [[ "$after_bracket" =~ ^(true|false|null) ]]; then
            echo "json"
            return
        fi
    fi

    # Markdown detection (common patterns)
    if [[ "$first_line" =~ ^#[[:space:]] ]] || \
       [[ "$content" =~ \`\`\` ]] || \
       [[ "$content" =~ ^\*\*.*\*\*$ ]] || \
       [[ "$content" =~ ^---$ ]]; then
        echo "markdown"
        return
    fi

    # XML/HTML detection
    if [[ "$first_line" =~ ^\<\?xml ]] || [[ "$first_line" =~ ^\<\!DOCTYPE ]] || \
       [[ "$first_line" =~ ^\<html ]]; then
        echo "xml"
        return
    fi

    # YAML detection (starts with ---)
    if [[ "$first_line" == "---" ]]; then
        echo "yaml"
        return
    fi

    echo "unknown"
}

# Get file extension
get_extension() {
    local file="$1"
    local ext="${file##*.}"
    echo "${ext,,}"  # lowercase
}

# Map extension to content type
extension_to_type() {
    local ext="$1"
    case "$ext" in
        md|markdown|mdown|mkd)
            echo "markdown"
            ;;
        json|jsonl)
            echo "json"
            ;;
        toml)
            echo "toml"
            ;;
        xml|xsl|xslt|svg|xhtml)
            echo "xml"
            ;;
        yaml|yml)
            echo "yaml"
            ;;
        csv)
            echo "csv"
            ;;
        py)
            echo "python"
            ;;
        sh|bash|zsh)
            echo "shell"
            ;;
        tmpl)
            echo "tmpl"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# View content with the appropriate tool
view_with_tool() {
    local content_type="$1"
    local file="$2"  # empty string for stdin
    local content="$3"  # content for stdin, empty for file

    case "$content_type" in
        json)
            if has_cmd jq; then
                if [[ -n "$file" ]]; then
                    jq -C '.' "$file" 2>/dev/null | less -R || less "$file"
                else
                    echo "$content" | jq -C '.' 2>/dev/null | less -R || echo "$content" | less
                fi
                return
            fi
            ;;
        markdown)
            if has_cmd glow; then
                if [[ -n "$file" ]]; then
                    glow -p "$file"
                else
                    echo "$content" | glow -p -
                fi
                return
            elif has_cmd bat; then
                if [[ -n "$file" ]]; then
                    bat -n --language=md "$file"
                else
                    echo "$content" | bat -n --language=md
                fi
                return
            fi
            ;;
        xml)
            if has_cmd xmllint && has_cmd bat; then
                if [[ -n "$file" ]]; then
                    xmllint --format "$file" 2>/dev/null | bat -n --language=xml || less "$file"
                else
                    echo "$content" | xmllint --format - 2>/dev/null | bat -n --language=xml || echo "$content" | less
                fi
                return
            elif has_cmd xmllint; then
                if [[ -n "$file" ]]; then
                    xmllint --format "$file" 2>/dev/null | less || less "$file"
                else
                    echo "$content" | xmllint --format - 2>/dev/null | less || echo "$content" | less
                fi
                return
            fi
            ;;
        yaml)
            if has_cmd yq && has_cmd bat; then
                if [[ -n "$file" ]]; then
                    yq -C '.' "$file" 2>/dev/null | less -R || less "$file"
                else
                    echo "$content" | yq -C '.' 2>/dev/null | less -R || echo "$content" | less
                fi
                return
            elif has_cmd bat; then
                if [[ -n "$file" ]]; then
                    bat -n --language=yaml "$file"
                else
                    echo "$content" | bat -n --language=yaml
                fi
                return
            fi
            ;;
        toml)
            if has_cmd bat; then
                if [[ -n "$file" ]]; then
                    bat -n --language=toml "$file"
                else
                    echo "$content" | bat -n --language=toml
                fi
                return
            fi
            ;;
        csv)
            if has_cmd column && has_cmd bat; then
                if [[ -n "$file" ]]; then
                    bat -n --color=always "$file" | column -t -s',' | less -R
                    # column -t -s',' "$file" | less -S
                else
                    echo "$content" | bat -n --color=always | column -t -s',' | less -R
                fi
                return
            elif has_cmd column; then
                if [[ -n "$file" ]]; then
                    column -t -s',' "$file" | less -S
                else
                    echo "$content" | column -t -s',' | less -R
                fi
                return
            elif has_cmd bat; then
                if [[ -n "$file" ]]; then
                    bat -n --color=always "$file"
                else
                    echo "$content" | bat -n --color=always 
                fi
                return
            fi
            ;;
        python|shell)
            if has_cmd bat; then
                local lang="$content_type"
                [[ "$lang" == "shell" ]] && lang="sh"
                if [[ -n "$file" ]]; then
                    bat -n --language="$lang" "$file"
                else
                    echo "$content" | bat -n --language="$lang"
                fi
                return
            fi
            ;;
        tmpl)
            if has_cmd bat; then
                # Strip .tmpl to get the underlying filename
                local base_name="${file%.tmpl}"
                local base_ext="${base_name##*.}"
                local lang=""

                # Check if base has a recognizable extension (not just a dotfile)
                if [[ "$base_name" != "$base_ext" && "$base_name" != ".$base_ext" ]]; then
                    lang="${base_ext,,}"
                    # Map common extensions to bat language names
                    case "$lang" in
                        yml) lang="yaml" ;;
                        py) lang="python" ;;
                        md) lang="markdown" ;;
                        sh|bash|zsh) lang="sh" ;;
                    esac
                fi

                # If no extension, use chezmoi to detect from processed content
                if [[ -z "$lang" ]] && has_cmd chezmoi; then
                    local processed
                    processed=$(chezmoi execute-template < "$file" 2>/dev/null)
                    local detected_type
                    detected_type=$(detect_content_type "$processed")
                    case "$detected_type" in
                        json) lang="json" ;;
                        markdown) lang="markdown" ;;
                        xml) lang="xml" ;;
                        yaml) lang="yaml" ;;
                    esac
                fi

                if [[ -n "$lang" ]]; then
                    bat -n --language="$lang" "$file"
                else
                    bat -n "$file"
                fi
                return
            fi
            ;;
    esac

    # Fallback: try bat for syntax highlighting, otherwise use less
    if has_cmd bat; then
        if [[ -n "$file" ]]; then
            bat -n --color=always "$file" 
        else
            echo "$content" | bat -n 
        fi
    else
        if [[ -n "$file" ]]; then
            less "$file"
        else
            echo "$content" | less
        fi
    fi
}

# Main logic
main() {
    # Handle stdin (piped content)
    if [[ ! -t 0 ]]; then
        local content
        content=$(cat)
        local content_type
        content_type=$(detect_content_type "$content")
        view_with_tool "$content_type" "" "$content"
        return
    fi

    # No arguments - just run less
    if [[ $# -eq 0 ]]; then
        less
        return
    fi

    # Handle file argument
    local file="$1"

    # Pass arguments (starting with -) through to bat/less
    if [[ "$file" == -* ]]; then
        if has_cmd bat; then
            bat "$@"
        else
            less "$@"
        fi
        return
    fi

    if [[ ! -f "$file" ]]; then
        echo "Error: '$file' is not a file" >&2
        exit 1
    fi

    # Determine content type from extension first
    local ext
    ext=$(get_extension "$file")
    local content_type
    content_type=$(extension_to_type "$ext")

    # If extension didn't help, try to detect from content
    if [[ "$content_type" == "unknown" ]]; then
        local sample
        sample=$(head -c 4096 "$file")
        content_type=$(detect_content_type "$sample")
    fi

    view_with_tool "$content_type" "$file" ""
}

main "$@"
